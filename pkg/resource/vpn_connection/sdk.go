// Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License"). You may
// not use this file except in compliance with the License. A copy of the
// License is located at
//
//     http://aws.amazon.com/apache2.0/
//
// or in the "license" file accompanying this file. This file is distributed
// on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
// express or implied. See the License for the specific language governing
// permissions and limitations under the License.

// Code generated by ack-generate. DO NOT EDIT.

package vpn_connection

import (
	"context"
	"strings"

	ackv1alpha1 "github.com/aws-controllers-k8s/runtime/apis/core/v1alpha1"
	ackcompare "github.com/aws-controllers-k8s/runtime/pkg/compare"
	ackerr "github.com/aws-controllers-k8s/runtime/pkg/errors"
	"github.com/aws/aws-sdk-go/aws"
	svcsdk "github.com/aws/aws-sdk-go/service/ec2"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"

	svcapitypes "github.com/aws-controllers-k8s/ec2-controller/apis/v1alpha1"
)

// Hack to avoid import errors during build...
var (
	_ = &metav1.Time{}
	_ = strings.ToLower("")
	_ = &aws.JSONValue{}
	_ = &svcsdk.EC2{}
	_ = &svcapitypes.VPNConnection{}
	_ = ackv1alpha1.AWSAccountID("")
	_ = &ackerr.NotFound
)

// sdkFind returns SDK-specific information about a supplied resource
func (rm *resourceManager) sdkFind(
	ctx context.Context,
	r *resource,
) (*resource, error) {
	input, err := rm.newListRequestPayload(r)
	if err != nil {
		return nil, err
	}

	resp, respErr := rm.sdkapi.DescribeVpnConnectionsWithContext(ctx, input)
	rm.metrics.RecordAPICall("READ_MANY", "DescribeVpnConnections", respErr)
	if respErr != nil {
		if awsErr, ok := ackerr.AWSError(respErr); ok && awsErr.Code() == "UNKNOWN" {
			return nil, ackerr.NotFound
		}
		return nil, respErr
	}

	// Merge in the information we read from the API call above to the copy of
	// the original Kubernetes object we passed to the function
	ko := r.ko.DeepCopy()

	found := false
	for _, elem := range resp.VpnConnections {
		if elem.Category != nil {
			ko.Status.Category = elem.Category
		}
		if elem.CustomerGatewayConfiguration != nil {
			ko.Status.CustomerGatewayConfiguration = elem.CustomerGatewayConfiguration
		}
		if elem.CustomerGatewayId != nil {
			ko.Spec.CustomerGatewayID = elem.CustomerGatewayId
		}
		if elem.Options != nil {
			f3 := &svcapitypes.VPNConnectionOptionsSpecification{}
			if elem.Options.EnableAcceleration != nil {
				f3.EnableAcceleration = elem.Options.EnableAcceleration
			}
			if elem.Options.LocalIpv4NetworkCidr != nil {
				f3.LocalIPv4NetworkCIDR = elem.Options.LocalIpv4NetworkCidr
			}
			if elem.Options.LocalIpv6NetworkCidr != nil {
				f3.LocalIPv6NetworkCIDR = elem.Options.LocalIpv6NetworkCidr
			}
			if elem.Options.RemoteIpv4NetworkCidr != nil {
				f3.RemoteIPv4NetworkCIDR = elem.Options.RemoteIpv4NetworkCidr
			}
			if elem.Options.RemoteIpv6NetworkCidr != nil {
				f3.RemoteIPv6NetworkCIDR = elem.Options.RemoteIpv6NetworkCidr
			}
			if elem.Options.StaticRoutesOnly != nil {
				f3.StaticRoutesOnly = elem.Options.StaticRoutesOnly
			}
			if elem.Options.TunnelInsideIpVersion != nil {
				f3.TunnelInsideIPVersion = elem.Options.TunnelInsideIpVersion
			}
			if elem.Options.TunnelOptions != nil {
				f3f7 := []*svcapitypes.VPNTunnelOptionsSpecification{}
				for _, f3f7iter := range elem.Options.TunnelOptions {
					f3f7elem := &svcapitypes.VPNTunnelOptionsSpecification{}
					if f3f7iter.Phase1DHGroupNumbers != nil {
						f3f7elemf4 := []*svcapitypes.Phase1DHGroupNumbersRequestListValue{}
						for _, f3f7elemf4iter := range f3f7iter.Phase1DHGroupNumbers {
							f3f7elemf4elem := &svcapitypes.Phase1DHGroupNumbersRequestListValue{}
							if f3f7elemf4iter.Value != nil {
								f3f7elemf4elem.Value = f3f7elemf4iter.Value
							}
							f3f7elemf4 = append(f3f7elemf4, f3f7elemf4elem)
						}
						f3f7elem.Phase1DHGroupNumbers = f3f7elemf4
					}
					if f3f7iter.Phase1EncryptionAlgorithms != nil {
						f3f7elemf5 := []*svcapitypes.Phase1EncryptionAlgorithmsRequestListValue{}
						for _, f3f7elemf5iter := range f3f7iter.Phase1EncryptionAlgorithms {
							f3f7elemf5elem := &svcapitypes.Phase1EncryptionAlgorithmsRequestListValue{}
							if f3f7elemf5iter.Value != nil {
								f3f7elemf5elem.Value = f3f7elemf5iter.Value
							}
							f3f7elemf5 = append(f3f7elemf5, f3f7elemf5elem)
						}
						f3f7elem.Phase1EncryptionAlgorithms = f3f7elemf5
					}
					if f3f7iter.Phase1IntegrityAlgorithms != nil {
						f3f7elemf6 := []*svcapitypes.Phase1IntegrityAlgorithmsRequestListValue{}
						for _, f3f7elemf6iter := range f3f7iter.Phase1IntegrityAlgorithms {
							f3f7elemf6elem := &svcapitypes.Phase1IntegrityAlgorithmsRequestListValue{}
							if f3f7elemf6iter.Value != nil {
								f3f7elemf6elem.Value = f3f7elemf6iter.Value
							}
							f3f7elemf6 = append(f3f7elemf6, f3f7elemf6elem)
						}
						f3f7elem.Phase1IntegrityAlgorithms = f3f7elemf6
					}
					if f3f7iter.Phase1LifetimeSeconds != nil {
						f3f7elem.Phase1LifetimeSeconds = f3f7iter.Phase1LifetimeSeconds
					}
					if f3f7iter.Phase2DHGroupNumbers != nil {
						f3f7elemf8 := []*svcapitypes.Phase2DHGroupNumbersRequestListValue{}
						for _, f3f7elemf8iter := range f3f7iter.Phase2DHGroupNumbers {
							f3f7elemf8elem := &svcapitypes.Phase2DHGroupNumbersRequestListValue{}
							if f3f7elemf8iter.Value != nil {
								f3f7elemf8elem.Value = f3f7elemf8iter.Value
							}
							f3f7elemf8 = append(f3f7elemf8, f3f7elemf8elem)
						}
						f3f7elem.Phase2DHGroupNumbers = f3f7elemf8
					}
					if f3f7iter.Phase2EncryptionAlgorithms != nil {
						f3f7elemf9 := []*svcapitypes.Phase2EncryptionAlgorithmsRequestListValue{}
						for _, f3f7elemf9iter := range f3f7iter.Phase2EncryptionAlgorithms {
							f3f7elemf9elem := &svcapitypes.Phase2EncryptionAlgorithmsRequestListValue{}
							if f3f7elemf9iter.Value != nil {
								f3f7elemf9elem.Value = f3f7elemf9iter.Value
							}
							f3f7elemf9 = append(f3f7elemf9, f3f7elemf9elem)
						}
						f3f7elem.Phase2EncryptionAlgorithms = f3f7elemf9
					}
					if f3f7iter.Phase2IntegrityAlgorithms != nil {
						f3f7elemf10 := []*svcapitypes.Phase2IntegrityAlgorithmsRequestListValue{}
						for _, f3f7elemf10iter := range f3f7iter.Phase2IntegrityAlgorithms {
							f3f7elemf10elem := &svcapitypes.Phase2IntegrityAlgorithmsRequestListValue{}
							if f3f7elemf10iter.Value != nil {
								f3f7elemf10elem.Value = f3f7elemf10iter.Value
							}
							f3f7elemf10 = append(f3f7elemf10, f3f7elemf10elem)
						}
						f3f7elem.Phase2IntegrityAlgorithms = f3f7elemf10
					}
					if f3f7iter.Phase2LifetimeSeconds != nil {
						f3f7elem.Phase2LifetimeSeconds = f3f7iter.Phase2LifetimeSeconds
					}
					if f3f7iter.PreSharedKey != nil {
						f3f7elem.PreSharedKey = f3f7iter.PreSharedKey
					}
					if f3f7iter.RekeyFuzzPercentage != nil {
						f3f7elem.RekeyFuzzPercentage = f3f7iter.RekeyFuzzPercentage
					}
					if f3f7iter.RekeyMarginTimeSeconds != nil {
						f3f7elem.RekeyMarginTimeSeconds = f3f7iter.RekeyMarginTimeSeconds
					}
					if f3f7iter.ReplayWindowSize != nil {
						f3f7elem.ReplayWindowSize = f3f7iter.ReplayWindowSize
					}
					if f3f7iter.StartupAction != nil {
						f3f7elem.StartupAction = f3f7iter.StartupAction
					}
					if f3f7iter.TunnelInsideCidr != nil {
						f3f7elem.TunnelInsideCIDR = f3f7iter.TunnelInsideCidr
					}
					if f3f7iter.TunnelInsideIpv6Cidr != nil {
						f3f7elem.TunnelInsideIPv6CIDR = f3f7iter.TunnelInsideIpv6Cidr
					}
					f3f7 = append(f3f7, f3f7elem)
				}
				f3.TunnelOptions = f3f7
			}
			ko.Spec.Options = f3
		}
		if elem.Routes != nil {
			f4 := []*svcapitypes.VPNStaticRoute{}
			for _, f4iter := range elem.Routes {
				f4elem := &svcapitypes.VPNStaticRoute{}
				if f4iter.DestinationCidrBlock != nil {
					f4elem.DestinationCIDRBlock = f4iter.DestinationCidrBlock
				}
				if f4iter.Source != nil {
					f4elem.Source = f4iter.Source
				}
				if f4iter.State != nil {
					f4elem.State = f4iter.State
				}
				f4 = append(f4, f4elem)
			}
			ko.Status.Routes = f4
		}
		if elem.State != nil {
			ko.Status.State = elem.State
		}
		if elem.Tags != nil {
			f6 := []*svcapitypes.Tag{}
			for _, f6iter := range elem.Tags {
				f6elem := &svcapitypes.Tag{}
				if f6iter.Key != nil {
					f6elem.Key = f6iter.Key
				}
				if f6iter.Value != nil {
					f6elem.Value = f6iter.Value
				}
				f6 = append(f6, f6elem)
			}
			ko.Status.Tags = f6
		}
		if elem.TransitGatewayId != nil {
			ko.Spec.TransitGatewayID = elem.TransitGatewayId
		}
		if elem.Type != nil {
			ko.Spec.Type = elem.Type
		}
		if elem.VgwTelemetry != nil {
			f9 := []*svcapitypes.VGWTelemetry{}
			for _, f9iter := range elem.VgwTelemetry {
				f9elem := &svcapitypes.VGWTelemetry{}
				if f9iter.AcceptedRouteCount != nil {
					f9elem.AcceptedRouteCount = f9iter.AcceptedRouteCount
				}
				if f9iter.CertificateArn != nil {
					f9elem.CertificateARN = f9iter.CertificateArn
				}
				if f9iter.LastStatusChange != nil {
					f9elem.LastStatusChange = &metav1.Time{*f9iter.LastStatusChange}
				}
				if f9iter.OutsideIpAddress != nil {
					f9elem.OutsideIPAddress = f9iter.OutsideIpAddress
				}
				if f9iter.Status != nil {
					f9elem.Status = f9iter.Status
				}
				if f9iter.StatusMessage != nil {
					f9elem.StatusMessage = f9iter.StatusMessage
				}
				f9 = append(f9, f9elem)
			}
			ko.Status.VGWTelemetry = f9
		}
		if elem.VpnConnectionId != nil {
			ko.Status.VPNConnectionID = elem.VpnConnectionId
		}
		if elem.VpnGatewayId != nil {
			ko.Spec.VPNGatewayID = elem.VpnGatewayId
		}
		found = true
		break
	}
	if !found {
		return nil, ackerr.NotFound
	}

	rm.setStatusDefaults(ko)

	return &resource{ko}, nil
}

// newListRequestPayload returns SDK-specific struct for the HTTP request
// payload of the List API call for the resource
func (rm *resourceManager) newListRequestPayload(
	r *resource,
) (*svcsdk.DescribeVpnConnectionsInput, error) {
	res := &svcsdk.DescribeVpnConnectionsInput{}

	if r.ko.Spec.DryRun != nil {
		res.SetDryRun(*r.ko.Spec.DryRun)
	}

	return res, nil
}

// sdkCreate creates the supplied resource in the backend AWS service API and
// returns a new resource with any fields in the Status field filled in
func (rm *resourceManager) sdkCreate(
	ctx context.Context,
	r *resource,
) (*resource, error) {
	input, err := rm.newCreateRequestPayload(ctx, r)
	if err != nil {
		return nil, err
	}

	resp, respErr := rm.sdkapi.CreateVpnConnectionWithContext(ctx, input)
	rm.metrics.RecordAPICall("CREATE", "CreateVpnConnection", respErr)
	if respErr != nil {
		return nil, respErr
	}
	// Merge in the information we read from the API call above to the copy of
	// the original Kubernetes object we passed to the function
	ko := r.ko.DeepCopy()

	if resp.VpnConnection.Category != nil {
		ko.Status.Category = resp.VpnConnection.Category
	}
	if resp.VpnConnection.CustomerGatewayConfiguration != nil {
		ko.Status.CustomerGatewayConfiguration = resp.VpnConnection.CustomerGatewayConfiguration
	}
	if resp.VpnConnection.Routes != nil {
		f4 := []*svcapitypes.VPNStaticRoute{}
		for _, f4iter := range resp.VpnConnection.Routes {
			f4elem := &svcapitypes.VPNStaticRoute{}
			if f4iter.DestinationCidrBlock != nil {
				f4elem.DestinationCIDRBlock = f4iter.DestinationCidrBlock
			}
			if f4iter.Source != nil {
				f4elem.Source = f4iter.Source
			}
			if f4iter.State != nil {
				f4elem.State = f4iter.State
			}
			f4 = append(f4, f4elem)
		}
		ko.Status.Routes = f4
	}
	if resp.VpnConnection.State != nil {
		ko.Status.State = resp.VpnConnection.State
	}
	if resp.VpnConnection.Tags != nil {
		f6 := []*svcapitypes.Tag{}
		for _, f6iter := range resp.VpnConnection.Tags {
			f6elem := &svcapitypes.Tag{}
			if f6iter.Key != nil {
				f6elem.Key = f6iter.Key
			}
			if f6iter.Value != nil {
				f6elem.Value = f6iter.Value
			}
			f6 = append(f6, f6elem)
		}
		ko.Status.Tags = f6
	}
	if resp.VpnConnection.VgwTelemetry != nil {
		f9 := []*svcapitypes.VGWTelemetry{}
		for _, f9iter := range resp.VpnConnection.VgwTelemetry {
			f9elem := &svcapitypes.VGWTelemetry{}
			if f9iter.AcceptedRouteCount != nil {
				f9elem.AcceptedRouteCount = f9iter.AcceptedRouteCount
			}
			if f9iter.CertificateArn != nil {
				f9elem.CertificateARN = f9iter.CertificateArn
			}
			if f9iter.LastStatusChange != nil {
				f9elem.LastStatusChange = &metav1.Time{*f9iter.LastStatusChange}
			}
			if f9iter.OutsideIpAddress != nil {
				f9elem.OutsideIPAddress = f9iter.OutsideIpAddress
			}
			if f9iter.Status != nil {
				f9elem.Status = f9iter.Status
			}
			if f9iter.StatusMessage != nil {
				f9elem.StatusMessage = f9iter.StatusMessage
			}
			f9 = append(f9, f9elem)
		}
		ko.Status.VGWTelemetry = f9
	}
	if resp.VpnConnection.VpnConnectionId != nil {
		ko.Status.VPNConnectionID = resp.VpnConnection.VpnConnectionId
	}

	rm.setStatusDefaults(ko)

	return &resource{ko}, nil
}

// newCreateRequestPayload returns an SDK-specific struct for the HTTP request
// payload of the Create API call for the resource
func (rm *resourceManager) newCreateRequestPayload(
	ctx context.Context,
	r *resource,
) (*svcsdk.CreateVpnConnectionInput, error) {
	res := &svcsdk.CreateVpnConnectionInput{}

	if r.ko.Spec.CustomerGatewayID != nil {
		res.SetCustomerGatewayId(*r.ko.Spec.CustomerGatewayID)
	}
	if r.ko.Spec.DryRun != nil {
		res.SetDryRun(*r.ko.Spec.DryRun)
	}
	if r.ko.Spec.Options != nil {
		f2 := &svcsdk.VpnConnectionOptionsSpecification{}
		if r.ko.Spec.Options.EnableAcceleration != nil {
			f2.SetEnableAcceleration(*r.ko.Spec.Options.EnableAcceleration)
		}
		if r.ko.Spec.Options.LocalIPv4NetworkCIDR != nil {
			f2.SetLocalIpv4NetworkCidr(*r.ko.Spec.Options.LocalIPv4NetworkCIDR)
		}
		if r.ko.Spec.Options.LocalIPv6NetworkCIDR != nil {
			f2.SetLocalIpv6NetworkCidr(*r.ko.Spec.Options.LocalIPv6NetworkCIDR)
		}
		if r.ko.Spec.Options.RemoteIPv4NetworkCIDR != nil {
			f2.SetRemoteIpv4NetworkCidr(*r.ko.Spec.Options.RemoteIPv4NetworkCIDR)
		}
		if r.ko.Spec.Options.RemoteIPv6NetworkCIDR != nil {
			f2.SetRemoteIpv6NetworkCidr(*r.ko.Spec.Options.RemoteIPv6NetworkCIDR)
		}
		if r.ko.Spec.Options.StaticRoutesOnly != nil {
			f2.SetStaticRoutesOnly(*r.ko.Spec.Options.StaticRoutesOnly)
		}
		if r.ko.Spec.Options.TunnelInsideIPVersion != nil {
			f2.SetTunnelInsideIpVersion(*r.ko.Spec.Options.TunnelInsideIPVersion)
		}
		if r.ko.Spec.Options.TunnelOptions != nil {
			f2f7 := []*svcsdk.VpnTunnelOptionsSpecification{}
			for _, f2f7iter := range r.ko.Spec.Options.TunnelOptions {
				f2f7elem := &svcsdk.VpnTunnelOptionsSpecification{}
				if f2f7iter.DPDTimeoutAction != nil {
					f2f7elem.SetDPDTimeoutAction(*f2f7iter.DPDTimeoutAction)
				}
				if f2f7iter.DPDTimeoutSeconds != nil {
					f2f7elem.SetDPDTimeoutSeconds(*f2f7iter.DPDTimeoutSeconds)
				}
				if f2f7iter.IKEVersions != nil {
					f2f7elemf2 := []*svcsdk.IKEVersionsRequestListValue{}
					for _, f2f7elemf2iter := range f2f7iter.IKEVersions {
						f2f7elemf2elem := &svcsdk.IKEVersionsRequestListValue{}
						if f2f7elemf2iter.Value != nil {
							f2f7elemf2elem.SetValue(*f2f7elemf2iter.Value)
						}
						f2f7elemf2 = append(f2f7elemf2, f2f7elemf2elem)
					}
					f2f7elem.SetIKEVersions(f2f7elemf2)
				}
				if f2f7iter.Phase1DHGroupNumbers != nil {
					f2f7elemf3 := []*svcsdk.Phase1DHGroupNumbersRequestListValue{}
					for _, f2f7elemf3iter := range f2f7iter.Phase1DHGroupNumbers {
						f2f7elemf3elem := &svcsdk.Phase1DHGroupNumbersRequestListValue{}
						if f2f7elemf3iter.Value != nil {
							f2f7elemf3elem.SetValue(*f2f7elemf3iter.Value)
						}
						f2f7elemf3 = append(f2f7elemf3, f2f7elemf3elem)
					}
					f2f7elem.SetPhase1DHGroupNumbers(f2f7elemf3)
				}
				if f2f7iter.Phase1EncryptionAlgorithms != nil {
					f2f7elemf4 := []*svcsdk.Phase1EncryptionAlgorithmsRequestListValue{}
					for _, f2f7elemf4iter := range f2f7iter.Phase1EncryptionAlgorithms {
						f2f7elemf4elem := &svcsdk.Phase1EncryptionAlgorithmsRequestListValue{}
						if f2f7elemf4iter.Value != nil {
							f2f7elemf4elem.SetValue(*f2f7elemf4iter.Value)
						}
						f2f7elemf4 = append(f2f7elemf4, f2f7elemf4elem)
					}
					f2f7elem.SetPhase1EncryptionAlgorithms(f2f7elemf4)
				}
				if f2f7iter.Phase1IntegrityAlgorithms != nil {
					f2f7elemf5 := []*svcsdk.Phase1IntegrityAlgorithmsRequestListValue{}
					for _, f2f7elemf5iter := range f2f7iter.Phase1IntegrityAlgorithms {
						f2f7elemf5elem := &svcsdk.Phase1IntegrityAlgorithmsRequestListValue{}
						if f2f7elemf5iter.Value != nil {
							f2f7elemf5elem.SetValue(*f2f7elemf5iter.Value)
						}
						f2f7elemf5 = append(f2f7elemf5, f2f7elemf5elem)
					}
					f2f7elem.SetPhase1IntegrityAlgorithms(f2f7elemf5)
				}
				if f2f7iter.Phase1LifetimeSeconds != nil {
					f2f7elem.SetPhase1LifetimeSeconds(*f2f7iter.Phase1LifetimeSeconds)
				}
				if f2f7iter.Phase2DHGroupNumbers != nil {
					f2f7elemf7 := []*svcsdk.Phase2DHGroupNumbersRequestListValue{}
					for _, f2f7elemf7iter := range f2f7iter.Phase2DHGroupNumbers {
						f2f7elemf7elem := &svcsdk.Phase2DHGroupNumbersRequestListValue{}
						if f2f7elemf7iter.Value != nil {
							f2f7elemf7elem.SetValue(*f2f7elemf7iter.Value)
						}
						f2f7elemf7 = append(f2f7elemf7, f2f7elemf7elem)
					}
					f2f7elem.SetPhase2DHGroupNumbers(f2f7elemf7)
				}
				if f2f7iter.Phase2EncryptionAlgorithms != nil {
					f2f7elemf8 := []*svcsdk.Phase2EncryptionAlgorithmsRequestListValue{}
					for _, f2f7elemf8iter := range f2f7iter.Phase2EncryptionAlgorithms {
						f2f7elemf8elem := &svcsdk.Phase2EncryptionAlgorithmsRequestListValue{}
						if f2f7elemf8iter.Value != nil {
							f2f7elemf8elem.SetValue(*f2f7elemf8iter.Value)
						}
						f2f7elemf8 = append(f2f7elemf8, f2f7elemf8elem)
					}
					f2f7elem.SetPhase2EncryptionAlgorithms(f2f7elemf8)
				}
				if f2f7iter.Phase2IntegrityAlgorithms != nil {
					f2f7elemf9 := []*svcsdk.Phase2IntegrityAlgorithmsRequestListValue{}
					for _, f2f7elemf9iter := range f2f7iter.Phase2IntegrityAlgorithms {
						f2f7elemf9elem := &svcsdk.Phase2IntegrityAlgorithmsRequestListValue{}
						if f2f7elemf9iter.Value != nil {
							f2f7elemf9elem.SetValue(*f2f7elemf9iter.Value)
						}
						f2f7elemf9 = append(f2f7elemf9, f2f7elemf9elem)
					}
					f2f7elem.SetPhase2IntegrityAlgorithms(f2f7elemf9)
				}
				if f2f7iter.Phase2LifetimeSeconds != nil {
					f2f7elem.SetPhase2LifetimeSeconds(*f2f7iter.Phase2LifetimeSeconds)
				}
				if f2f7iter.PreSharedKey != nil {
					f2f7elem.SetPreSharedKey(*f2f7iter.PreSharedKey)
				}
				if f2f7iter.RekeyFuzzPercentage != nil {
					f2f7elem.SetRekeyFuzzPercentage(*f2f7iter.RekeyFuzzPercentage)
				}
				if f2f7iter.RekeyMarginTimeSeconds != nil {
					f2f7elem.SetRekeyMarginTimeSeconds(*f2f7iter.RekeyMarginTimeSeconds)
				}
				if f2f7iter.ReplayWindowSize != nil {
					f2f7elem.SetReplayWindowSize(*f2f7iter.ReplayWindowSize)
				}
				if f2f7iter.StartupAction != nil {
					f2f7elem.SetStartupAction(*f2f7iter.StartupAction)
				}
				if f2f7iter.TunnelInsideCIDR != nil {
					f2f7elem.SetTunnelInsideCidr(*f2f7iter.TunnelInsideCIDR)
				}
				if f2f7iter.TunnelInsideIPv6CIDR != nil {
					f2f7elem.SetTunnelInsideIpv6Cidr(*f2f7iter.TunnelInsideIPv6CIDR)
				}
				f2f7 = append(f2f7, f2f7elem)
			}
			f2.SetTunnelOptions(f2f7)
		}
		res.SetOptions(f2)
	}
	if r.ko.Spec.TagSpecifications != nil {
		f3 := []*svcsdk.TagSpecification{}
		for _, f3iter := range r.ko.Spec.TagSpecifications {
			f3elem := &svcsdk.TagSpecification{}
			if f3iter.ResourceType != nil {
				f3elem.SetResourceType(*f3iter.ResourceType)
			}
			if f3iter.Tags != nil {
				f3elemf1 := []*svcsdk.Tag{}
				for _, f3elemf1iter := range f3iter.Tags {
					f3elemf1elem := &svcsdk.Tag{}
					if f3elemf1iter.Key != nil {
						f3elemf1elem.SetKey(*f3elemf1iter.Key)
					}
					if f3elemf1iter.Value != nil {
						f3elemf1elem.SetValue(*f3elemf1iter.Value)
					}
					f3elemf1 = append(f3elemf1, f3elemf1elem)
				}
				f3elem.SetTags(f3elemf1)
			}
			f3 = append(f3, f3elem)
		}
		res.SetTagSpecifications(f3)
	}
	if r.ko.Spec.TransitGatewayID != nil {
		res.SetTransitGatewayId(*r.ko.Spec.TransitGatewayID)
	}
	if r.ko.Spec.Type != nil {
		res.SetType(*r.ko.Spec.Type)
	}
	if r.ko.Spec.VPNGatewayID != nil {
		res.SetVpnGatewayId(*r.ko.Spec.VPNGatewayID)
	}

	return res, nil
}

// sdkUpdate patches the supplied resource in the backend AWS service API and
// returns a new resource with updated fields.
func (rm *resourceManager) sdkUpdate(
	ctx context.Context,
	desired *resource,
	latest *resource,
	diffReporter *ackcompare.Reporter,
) (*resource, error) {

	input, err := rm.newUpdateRequestPayload(ctx, desired)
	if err != nil {
		return nil, err
	}

	resp, respErr := rm.sdkapi.ModifyVpnConnectionWithContext(ctx, input)
	rm.metrics.RecordAPICall("UPDATE", "ModifyVpnConnection", respErr)
	if respErr != nil {
		return nil, respErr
	}
	// Merge in the information we read from the API call above to the copy of
	// the original Kubernetes object we passed to the function
	ko := desired.ko.DeepCopy()

	if resp.VpnConnection.Category != nil {
		ko.Status.Category = resp.VpnConnection.Category
	}
	if resp.VpnConnection.CustomerGatewayConfiguration != nil {
		ko.Status.CustomerGatewayConfiguration = resp.VpnConnection.CustomerGatewayConfiguration
	}
	if resp.VpnConnection.Routes != nil {
		f4 := []*svcapitypes.VPNStaticRoute{}
		for _, f4iter := range resp.VpnConnection.Routes {
			f4elem := &svcapitypes.VPNStaticRoute{}
			if f4iter.DestinationCidrBlock != nil {
				f4elem.DestinationCIDRBlock = f4iter.DestinationCidrBlock
			}
			if f4iter.Source != nil {
				f4elem.Source = f4iter.Source
			}
			if f4iter.State != nil {
				f4elem.State = f4iter.State
			}
			f4 = append(f4, f4elem)
		}
		ko.Status.Routes = f4
	}
	if resp.VpnConnection.State != nil {
		ko.Status.State = resp.VpnConnection.State
	}
	if resp.VpnConnection.Tags != nil {
		f6 := []*svcapitypes.Tag{}
		for _, f6iter := range resp.VpnConnection.Tags {
			f6elem := &svcapitypes.Tag{}
			if f6iter.Key != nil {
				f6elem.Key = f6iter.Key
			}
			if f6iter.Value != nil {
				f6elem.Value = f6iter.Value
			}
			f6 = append(f6, f6elem)
		}
		ko.Status.Tags = f6
	}
	if resp.VpnConnection.VgwTelemetry != nil {
		f9 := []*svcapitypes.VGWTelemetry{}
		for _, f9iter := range resp.VpnConnection.VgwTelemetry {
			f9elem := &svcapitypes.VGWTelemetry{}
			if f9iter.AcceptedRouteCount != nil {
				f9elem.AcceptedRouteCount = f9iter.AcceptedRouteCount
			}
			if f9iter.CertificateArn != nil {
				f9elem.CertificateARN = f9iter.CertificateArn
			}
			if f9iter.LastStatusChange != nil {
				f9elem.LastStatusChange = &metav1.Time{*f9iter.LastStatusChange}
			}
			if f9iter.OutsideIpAddress != nil {
				f9elem.OutsideIPAddress = f9iter.OutsideIpAddress
			}
			if f9iter.Status != nil {
				f9elem.Status = f9iter.Status
			}
			if f9iter.StatusMessage != nil {
				f9elem.StatusMessage = f9iter.StatusMessage
			}
			f9 = append(f9, f9elem)
		}
		ko.Status.VGWTelemetry = f9
	}
	if resp.VpnConnection.VpnConnectionId != nil {
		ko.Status.VPNConnectionID = resp.VpnConnection.VpnConnectionId
	}

	rm.setStatusDefaults(ko)

	return &resource{ko}, nil
}

// newUpdateRequestPayload returns an SDK-specific struct for the HTTP request
// payload of the Update API call for the resource
func (rm *resourceManager) newUpdateRequestPayload(
	ctx context.Context,
	r *resource,
) (*svcsdk.ModifyVpnConnectionInput, error) {
	res := &svcsdk.ModifyVpnConnectionInput{}

	if r.ko.Spec.CustomerGatewayID != nil {
		res.SetCustomerGatewayId(*r.ko.Spec.CustomerGatewayID)
	}
	if r.ko.Spec.DryRun != nil {
		res.SetDryRun(*r.ko.Spec.DryRun)
	}
	if r.ko.Spec.TransitGatewayID != nil {
		res.SetTransitGatewayId(*r.ko.Spec.TransitGatewayID)
	}
	if r.ko.Status.VPNConnectionID != nil {
		res.SetVpnConnectionId(*r.ko.Status.VPNConnectionID)
	}
	if r.ko.Spec.VPNGatewayID != nil {
		res.SetVpnGatewayId(*r.ko.Spec.VPNGatewayID)
	}

	return res, nil
}

// sdkDelete deletes the supplied resource in the backend AWS service API
func (rm *resourceManager) sdkDelete(
	ctx context.Context,
	r *resource,
) error {

	input, err := rm.newDeleteRequestPayload(r)
	if err != nil {
		return err
	}
	_, respErr := rm.sdkapi.DeleteVpnConnectionWithContext(ctx, input)
	rm.metrics.RecordAPICall("DELETE", "DeleteVpnConnection", respErr)
	return respErr
}

// newDeleteRequestPayload returns an SDK-specific struct for the HTTP request
// payload of the Delete API call for the resource
func (rm *resourceManager) newDeleteRequestPayload(
	r *resource,
) (*svcsdk.DeleteVpnConnectionInput, error) {
	res := &svcsdk.DeleteVpnConnectionInput{}

	if r.ko.Spec.DryRun != nil {
		res.SetDryRun(*r.ko.Spec.DryRun)
	}
	if r.ko.Status.VPNConnectionID != nil {
		res.SetVpnConnectionId(*r.ko.Status.VPNConnectionID)
	}

	return res, nil
}

// setStatusDefaults sets default properties into supplied custom resource
func (rm *resourceManager) setStatusDefaults(
	ko *svcapitypes.VPNConnection,
) {
	if ko.Status.ACKResourceMetadata == nil {
		ko.Status.ACKResourceMetadata = &ackv1alpha1.ResourceMetadata{}
	}
	if ko.Status.ACKResourceMetadata.OwnerAccountID == nil {
		ko.Status.ACKResourceMetadata.OwnerAccountID = &rm.awsAccountID
	}
	if ko.Status.Conditions == nil {
		ko.Status.Conditions = []*ackv1alpha1.Condition{}
	}
}

// updateConditions returns updated resource, true; if conditions were updated
// else it returns nil, false
func (rm *resourceManager) updateConditions(
	r *resource,
	err error,
) (*resource, bool) {
	ko := r.ko.DeepCopy()
	rm.setStatusDefaults(ko)

	// Terminal condition
	var terminalCondition *ackv1alpha1.Condition = nil
	for _, condition := range ko.Status.Conditions {
		if condition.Type == ackv1alpha1.ConditionTypeTerminal {
			terminalCondition = condition
			break
		}
	}

	if rm.terminalAWSError(err) {
		if terminalCondition == nil {
			terminalCondition = &ackv1alpha1.Condition{
				Type: ackv1alpha1.ConditionTypeTerminal,
			}
			ko.Status.Conditions = append(ko.Status.Conditions, terminalCondition)
		}
		terminalCondition.Status = corev1.ConditionTrue
		awsErr, _ := ackerr.AWSError(err)
		errorMessage := awsErr.Message()
		terminalCondition.Message = &errorMessage
	} else if terminalCondition != nil {
		terminalCondition.Status = corev1.ConditionFalse
		terminalCondition.Message = nil
	}
	if terminalCondition != nil {
		return &resource{ko}, true // updated
	}
	return nil, false // not updated
}

// terminalAWSError returns awserr, true; if the supplied error is an aws Error type
// and if the exception indicates that it is a Terminal exception
// 'Terminal' exception are specified in generator configuration
func (rm *resourceManager) terminalAWSError(err error) bool {
	// No terminal_errors specified for this resource in generator config
	return false
}
